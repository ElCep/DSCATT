;; -22 quand pas de fumier  (dire d'acteur)
;; animaux qui mange quand le champs qui sont dans la jachère font perdre de la récole

to-report production [c]  
 ;;show [ idmyParcellesCultive ] of c
  let pids [ idmyParcellesCultive ] of c
  let parcelles map [pid -> patches with [ parcelle-id = pid ]] pids
  let prod map [ p -> production-parcelle p ] parcelles
  report sum prod
end

to-report production-parcelle[pid]
  let pp patches with [ parcelle-id = pid ]
  
  if not any? pp [ report 0 ]
  
  let parcelle-fertilite sum [fertilite] of pp
  let raw-production count pp * surface-de-patch * kg-cereale-par-ha / 10000
  
  let malus-f ifelse-value parcelle-fertilite < 0 [ malus-fertilite ] [0] 
  let malus-j ifelse-value [ cycle ] of (one-of pp) = 3  [ malus-in-jachere ] [0]
  let malus malus-f + malus-j 
  
  report ifelse-value parcelle-fertilite > 0 [ raw-production ] [ raw-production - raw-production * malus]
end


to ordre-parcelles
;; chaque cuisine doit mettre en culture ses parcelles pour nourrir ses membre.
;; il faut donc avoir calculer le besoin de chaque cuisine
;; 1 trouver les parcelles les plus proches, c.a.d. reordonnancer les id des parcelles par la distance
  
  ask cuisines [
    let myParcelles remove-duplicates [parcelle-id] of patches with [proprietaire = myself] ; liste des ID de toutes mes parcelles
    ;; pour chaque parcelle je récupère la distance minimal
    let patchDistance []
    foreach myParcelles [
      x -> let minDist min-one-of patches with[parcelle-id = x][distance myself] ;renvoie un patches qui a la plus petite distance
      ask minDist [
       set myDistFromCuisine distance myself 
      ]
    ]
    
    let mySmallPatches patches with[proprietaire = myself and myDistFromCuisine != 0]
    let myParcellesSorted sort-by [[p1 p2]-> distance p1 < distance p2 ] mySmallPatches
    set idmyParcellesSorted []
    foreach myParcellesSorted [
      x -> let _a [parcelle-id] of x
      set  idmyParcellesSorted lput _a idmyParcellesSorted
    ]
    ]
end

to planif-culture
; recupérer les surface des parcelles 
; mettre en culture
; mettre a jour mon besoin et mettre en culture temps que le les besoin ne sont pas 
  ask couverts [die]
  ask cuisines [
    let actualBesoin besoin-nourriture
    let i length idmyParcellesSorted
    let iter 1
    foreach  idmyParcellesSorted [
      x -> let myactualParcelle patches with[parcelle-id = x and cycle < 3 ]
      ifelse (actualBesoin > 0) [ ; temps que je n'ai pas assouvie mes besoin j'itère sur mes parcelles
        let surface-parcelle count myactualParcelle
        let besoin-assouvi-parcelle (surface-parcelle * surface-de-patch  /  10000) * kg-cereale-par-ha
        set actualBesoin actualBesoin - besoin-assouvi-parcelle
        ask myactualParcelle [
          set cultived? TRUE  
        ]
        
        set idmyParcellesCultive lput x idmyParcellesCultive  
        if (i = iter)[
          set tropParcelles? FALSE
          show "pas assez de parcelle"
        ]
        set iter iter + 1
      ][
        set tropParcelles? TRUE
        show "tranquille"
      ]
    ]
  ]
  
end


to update-inti-tick
  ask patches [
    set cultived? FALSE
  ]
  
  ask cuisines [
   set tropParcelles? FALSE
    set idmyParcellesCultive []
  ]
  
end


to mise-en-culture
  show "paf ça plante"
  ask patches with[cultived? = TRUE][
          sprout-couverts 1 [
            set shape "plant"
          ]
  ]
end
