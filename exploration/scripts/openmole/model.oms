import dscatt.*

val rotationCycle = Val[RotationCycle]
val soilQualityBasis = Val[Double]
val fallowBoost = Val[Double]
val cropResidueBoost = Val[Double]
val populationGrowth = Val[Double]
val peanutSeedToFood = Val[Double]
val sqrf = Val[Double]

val last5yearsAveragePopulation = Val[Double]
val populationDynamic = Val[Array[Int]]
val kitchenSizeDynamic = Val[Array[Double]]
val populationRSquare = Val[Double]
val populationSlope = Val[Double]
val kitchenSizeAverage = Val[Double]
val averageMilYield = Val[Double]

val last5yearsAverageHerdSize = Val[Double]
val numberOfUnbalancedKitchen = Val[Int]
val foodStress = Val[Array[Double]]
val milYieldDynamic = Val[Array[Double]]

val numberOfKitchens = Val[Array[Int]]
val effectiveFallowRatioDynamic = Val[Array[Double]]
val herdDynamic = Val[Array[Int]]

val rainFall = Val[Seq[Int]]
val lastPopulation = Val[Int]
val annualSoilQuality = Val[Array[Double]]
val residualSoilQuality = Val[Array[Double]]
val lastEffectiveFallowRatio = Val[Double]
val migrantDynamic=Val[Array[Int]]

val peanutForInexcess = Val[Double]
val ownFallowUse = Val[OwnFallowUse]
val loanStrategy = Val[LoanStrategy]
val foodDonation = Val[FoodDonationStrategy]
val drySeasonHerdStrategy=Val[HerdGrazingStrategy]
val wetSeasonHerdStrategy=Val[HerdGrazingStrategy]
val giniParcels = Val[Double]
val mulching=Val[Double]
val nbFaidherbia=Val[Int]
val lastHerdSize=Val[Int]
val lastMilYield=Val[Double]
val medianMilYield=Val[Double]
val erosion=Val[Double]
val nbAbsorbedKitchens=Val[Int]
val lsuByArea=Val[Double]
val seed = Val[Long]
val lands = Val[File]

val model = ScalaTask(
"""
import dscatt.*

val hookFile = Diohine.HookFile(
outputPath = "/tmp",
parcels = false,
kitchens = false,
dynamics = false
)

val hooks = Diohine.HookParameters(
displayParcels = false,
displayKitchens = false,
hookFile = Some(hookFile)
)

val manureDepositStategyMilNextYear = { (p: Parcel, r: RotationCycle) =>
Croping.evolveCrop(p.crop, r, Croping.evolveCropZone(p.cropZone, r)) == Croping.Millet
}

val kitchenProfile1 = KitchenProfile(
9999,
kitchenSize = 16,
rotationCycle = rotationCycle,
CropingStrategy.PeanutForInexcess(peanutForInexcess),
ownFallowUse = ownFallowUse,
loanStrategy = loanStrategy,
foodDonationStrategy = foodDonation,
drySeasonHerdStrategy = drySeasonHerdStrategy,
wetSeasonHerdStrategy = wetSeasonHerdStrategy,
herdSizeStrategy = HerdSizeStrategy.LSUByArea(lsuByArea),
manureDepositStategyMilNextYear,
FertilizerStrategy.UniformFertilizing,
MulchingStrategy.NoMulching,
nbFaidherbia = nbFaidherbia
)

val kitchenPartition = KitchenPartition(Seq((kitchenProfile1, 22)))
val supportPolicy = SupportPolicy(taxPayerRatio = 1, fertilizerWeightPerYear = _ => kitchenPartition.profiles.map(_._2).sum * 20)

val rnd = scala.util.Random(seed)
val sampledSeed = rnd.nextInt(1000) + 1

val (simulationState, simulationData) = Simulation(
seed = sampledSeed,
lands = java.io.File(lands, s"s${sampledSeed}k22g0,20.json"),
populationGrowth = populationGrowth,
kitchenPartition = kitchenPartition,
supportPolicy = supportPolicy,
simulationLength = 26,
soilQualityBasis = soilQualityBasis,
fallowBoost = fallowBoost,
cropResidueBoost = cropResidueBoost,
erosion=erosion,
sqrf=sqrf,
peanutSeedToFood = peanutSeedToFood,
dailyFoodNeedPerPerson = 0.555,
hookParameters = hooks,
rainFall = rainFall
)


given data: Data = simulationData


val populationDynamic = simulationState.populationDynamic
val kitchenSizeDynamic = simulationState.averageKitchenSizeDynamic

val (populationRSquare, populationSlope) = simulationState.populationRSquareAndSlope

val milYieldAverage = simulationState.averageMilYieldDynamic.average
val milYieldDynamic = simulationState.averageMilYieldDynamic

val kitchenSizeAverage = simulationState.averageKitchenSizeDynamic.average

val numberOfKitchens = simulationState.numberOfKitchens

val effectiveFallowRatioDynamic = simulationState.effectiveFallowRatioDynamic

val herdDynamic = simulationState.herdDynamic
val lastHerdSize = simulationState.herdDynamic.last

val lastPopulation = simulationState.populationDynamic.last
val annualSoilQuality = simulationState.averageAnnualSoilQualityDynamic
val residualSoilQuality = simulationState.averageResidualSoilQualityDynamic
//val lastEffectiveFallowRatio = simulationState.effectiveFallowRatioDynamic.last
val lastMilYield = simulationState.averageMilYieldDynamic.last
val migrantDynamic = simulationState.migrantsDynamic
val nbAbsorbedKitchens = simulationState.numberOfAbsorbedKitchens
"""
) set (
inputs += (peanutSeedToFood, peanutForInexcess, cropResidueBoost, nbFaidherbia, giniParcels, fallowBoost, populationGrowth, lsuByArea, rainFall),
outputs += (populationSlope, populationRSquare, populationDynamic, milYieldDynamic, populationGrowth,
kitchenSizeAverage, effectiveFallowRatioDynamic, kitchenSizeDynamic, fallowBoost, annualSoilQuality, residualSoilQuality, lsuByArea,
herdDynamic, migrantDynamic, lastPopulation, lastMilYield, lastHerdSize, nbAbsorbedKitchens, milYieldDynamic),
seed := 7L,
soilQualityBasis := 100.0, // optim
fallowBoost := 6.171808467006881,
cropResidueBoost := 0.0,
erosion := 0.004407454871925849,
sqrf := 0.01739657088046872,
rotationCycle := RotationCycle.FallowMilletPeanut,
ownFallowUse := OwnFallowUse.NeverUseFallow,
loanStrategy := LoanStrategy.AllExtraParcelsLoaner,
foodDonation := FoodDonationStrategy.FoodForAllStrategy,
drySeasonHerdStrategy := HerdGrazingStrategy.EverywhereByDayOwnerByNight,
wetSeasonHerdStrategy := HerdGrazingStrategy.EverywhereByDayOwnerByNight,
peanutSeedToFood := 1.5000723600474144,
peanutForInexcess := 0.0,
nbFaidherbia := 4,
giniParcels := 0.2,
populationGrowth := 0.014539331772985376,
rainFall := Seq(623,623,404,408,388,729,620,528,394,484,395,635,540,526,652,691,720,416,723,536,353,767,527,509,501,501),
lsuByArea := 0.42,
lands := workDirectory / "lands"
)

model hook display //(workDirectory / "resultsM")
//diohinemodel1Task hook display